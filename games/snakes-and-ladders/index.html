<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>×¡×•×œ××•×ª ×•× ×—×©×™× ğŸ²</title>
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ğŸ²</text></svg>">
<link href="https://fonts.googleapis.com/css2?family=Rubik:wght@400;600;700;800;900&display=swap" rel="stylesheet">
<style>
:root {
  --bg: #0f172a;
  --surface: #1e293b;
  --surface2: #253449;
  --border: rgba(255,255,255,0.08);
  --text: #f1f5f9;
  --dim: rgba(255,255,255,0.5);
  --p1: #f472b6; --p1g: rgba(244,114,182,0.25);
  --p2: #60a5fa; --p2g: rgba(96,165,250,0.25);
  --p3: #4ade80; --p3g: rgba(74,222,128,0.25);
  --p4: #fb923c; --p4g: rgba(251,146,60,0.25);
  --ladder: #22c55e;
  --snake: #ef4444;
}
* { margin:0; padding:0; box-sizing:border-box; }
html, body { height:100%; overflow:hidden; }
body {
  font-family:'Rubik',sans-serif;
  background:var(--bg);
  color:var(--text);
  display:flex; flex-direction:column;
}

/* â”€â”€ Setup Screen â”€â”€ */
.setup-overlay {
  position:fixed; inset:0; z-index:100;
  background:var(--bg);
  display:flex; align-items:center; justify-content:center;
  padding:20px;
}
.setup-overlay.hidden { display:none; }
.setup-card {
  background:var(--surface);
  border:1px solid var(--border);
  border-radius:24px;
  padding:36px 32px;
  max-width:420px; width:100%;
  text-align:center;
}
.setup-icon { font-size:3.5em; margin-bottom:12px; animation:setupBounce 2s ease-in-out infinite; }
@keyframes setupBounce { 0%,100%{transform:translateY(0)} 50%{transform:translateY(-10px)} }
.setup-card h1 {
  font-size:1.7em; font-weight:900;
  background:linear-gradient(135deg,#f472b6,#60a5fa,#4ade80);
  -webkit-background-clip:text; -webkit-text-fill-color:transparent; background-clip:text;
  margin-bottom:6px;
}
.setup-card .subtitle { color:var(--dim); font-size:0.95em; margin-bottom:24px; }
.player-select { display:flex; gap:10px; justify-content:center; margin-bottom:20px; }
.psel {
  flex:1; padding:14px 8px; border-radius:16px;
  border:2px solid var(--border); background:transparent;
  color:var(--text); font-family:'Rubik',sans-serif;
  cursor:pointer; transition:all 0.25s; display:flex; flex-direction:column; align-items:center; gap:2px;
}
.psel:hover { border-color:rgba(255,255,255,0.2); background:rgba(255,255,255,0.04); }
.psel.active { border-color:var(--p2); background:rgba(96,165,250,0.1); }
.psel-num { font-size:1.6em; font-weight:900; }
.psel-label { font-size:0.7em; font-weight:600; color:var(--dim); }
.player-preview {
  display:flex; justify-content:center; gap:12px; margin-bottom:24px;
  min-height:56px; align-items:center; flex-wrap:wrap;
}
.preview-chip {
  display:flex; align-items:center; gap:5px;
  padding:6px 14px; border-radius:12px;
  font-size:0.85em; font-weight:700;
  transition:all 0.3s;
}
.btn-start {
  width:100%; padding:14px; border-radius:16px; border:none;
  font-family:'Rubik',sans-serif; font-size:1.15em; font-weight:800;
  cursor:pointer; color:#fff;
  background:linear-gradient(135deg,#f59e0b,#ef4444,#ec4899);
  transition:all 0.25s;
}
.btn-start:hover { filter:brightness(1.15); transform:translateY(-2px); }
.btn-start:active { transform:translateY(0); }

/* â”€â”€ Game UI â”€â”€ */
.game-wrap { display:none; flex-direction:column; height:100%; }
.game-wrap.active { display:flex; }
.back-btn {
  position:fixed; top:10px; left:10px; z-index:9999;
  background:rgba(0,0,0,0.5); color:#fff; text-decoration:none;
  padding:6px 14px; border-radius:12px; font-size:0.85em;
  backdrop-filter:blur(8px); -webkit-backdrop-filter:blur(8px);
}
.top-bar {
  display:flex; align-items:center; justify-content:space-between;
  padding:10px 16px; background:var(--surface);
  border-bottom:1px solid var(--border); flex-shrink:0;
}
.top-bar h1 {
  font-size:1.05em; font-weight:800;
  background:linear-gradient(135deg,#f472b6,#60a5fa);
  -webkit-background-clip:text; -webkit-text-fill-color:transparent; background-clip:text;
}
.players-bar { display:flex; gap:8px; font-size:0.8em; font-weight:700; flex-wrap:wrap; }
.players-bar .p {
  display:flex; align-items:center; gap:4px;
  padding:4px 10px; border-radius:10px;
  transition:all 0.3s;
}
.players-bar .p.active { outline:2px solid #fff; outline-offset:2px; transform:scale(1.05); }
.game-area {
  flex:1; display:flex; align-items:center; justify-content:center;
  padding:8px; overflow:hidden; position:relative;
}
canvas { border-radius:12px; }
.bottom-bar {
  display:flex; align-items:center; justify-content:center;
  gap:12px; padding:12px 16px;
  background:var(--surface); border-top:1px solid var(--border); flex-shrink:0;
}
.btn {
  padding:12px 28px; border-radius:14px; border:none;
  font-family:'Rubik',sans-serif; font-size:1em; font-weight:800;
  cursor:pointer; color:#fff; transition:all 0.2s;
}
.btn:hover { filter:brightness(1.15); transform:translateY(-1px); }
.btn:active { transform:translateY(0); }
.btn-roll { background:linear-gradient(135deg,#f59e0b,#ef4444); font-size:1.1em; }
.btn-roll:disabled { opacity:0.4; cursor:not-allowed; transform:none; }
.btn-new { background:rgba(255,255,255,0.1); font-size:0.85em; }
.dice-display {
  font-size:2.2em; min-width:56px; text-align:center;
  transition:transform 0.3s;
}
.dice-display.rolling { animation:shake 0.12s infinite; }
@keyframes shake {
  0%,100%{transform:rotate(0)} 25%{transform:rotate(-15deg)} 75%{transform:rotate(15deg)}
}

/* â”€â”€ Event Toast â”€â”€ */
.event-toast {
  position:absolute; top:20%; left:50%; transform:translate(-50%,-50%) scale(0);
  padding:16px 28px; border-radius:18px;
  font-size:1.3em; font-weight:800; text-align:center;
  z-index:60; pointer-events:none;
  opacity:0; transition:none;
}
.event-toast.ladder-toast {
  background:rgba(34,197,94,0.2); border:2px solid rgba(34,197,94,0.4);
  color:#4ade80; backdrop-filter:blur(12px);
}
.event-toast.snake-toast {
  background:rgba(239,68,68,0.2); border:2px solid rgba(239,68,68,0.4);
  color:#f87171; backdrop-filter:blur(12px);
}
.event-toast.show {
  animation:toastIn 0.4s ease forwards, toastOut 0.4s ease 1.2s forwards;
}
@keyframes toastIn {
  0% { opacity:0; transform:translate(-50%,-50%) scale(0.5); }
  100% { opacity:1; transform:translate(-50%,-50%) scale(1); }
}
@keyframes toastOut {
  0% { opacity:1; transform:translate(-50%,-50%) scale(1); }
  100% { opacity:0; transform:translate(-50%,-50%) scale(0.5) translateY(-20px); }
}

/* â”€â”€ Win overlay â”€â”€ */
.msg {
  position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
  background:rgba(0,0,0,0.88); backdrop-filter:blur(16px);
  padding:32px 44px; border-radius:24px; text-align:center;
  z-index:50; pointer-events:auto; display:none;
  border:1px solid var(--border);
}
.msg h2 { font-size:1.8em; margin-bottom:8px; }
.msg p { color:var(--dim); margin-bottom:18px; font-size:1.05em; }
.msg .btn { pointer-events:auto; }

/* â”€â”€ Confetti Canvas â”€â”€ */
#confetti {
  position:fixed; inset:0; z-index:45; pointer-events:none;
}
</style>
</head>
<body>

<a href="../../" class="back-btn">ğŸ  ××©×—×§×™×</a>

<!-- Setup Screen -->
<div class="setup-overlay" id="setupScreen">
  <div class="setup-card">
    <div class="setup-icon">ğŸğŸªœ</div>
    <h1>×¡×•×œ××•×ª ×•× ×—×©×™×</h1>
    <p class="subtitle">×‘×—×¨×• ××¡×¤×¨ ×©×—×§× ×™× ×•×”×ª×—×™×œ×•!</p>
    <div class="player-select">
      <button class="psel active" onclick="selectPlayers(2)">
        <span class="psel-num">2</span><span class="psel-label">×©×—×§× ×™×</span>
      </button>
      <button class="psel" onclick="selectPlayers(3)">
        <span class="psel-num">3</span><span class="psel-label">×©×—×§× ×™×</span>
      </button>
      <button class="psel" onclick="selectPlayers(4)">
        <span class="psel-num">4</span><span class="psel-label">×©×—×§× ×™×</span>
      </button>
    </div>
    <div class="player-preview" id="playerPreview"></div>
    <button class="btn-start" onclick="startGame()">ğŸ® ×”×ª×—×™×œ×• ×œ×©×—×§!</button>
  </div>
</div>

<!-- Game -->
<div class="game-wrap" id="gameWrap">
  <div class="top-bar">
    <h1>ğŸ ×¡×•×œ××•×ª ×•× ×—×©×™× ğŸªœ</h1>
    <div class="players-bar" id="playersBar"></div>
  </div>

  <div class="game-area">
    <canvas id="board"></canvas>
    <div class="event-toast" id="eventToast"></div>
    <div class="msg" id="winMsg">
      <h2 id="winTitle">ğŸ‰ × ×™×¦×—×•×Ÿ!</h2>
      <p id="winText"></p>
      <button class="btn btn-roll" onclick="backToSetup()">ğŸ”„ ××©×—×§ ×—×“×©</button>
    </div>
  </div>

  <div class="bottom-bar">
    <button class="btn btn-new" onclick="backToSetup()">ğŸ”„ ×—×“×©</button>
    <div class="dice-display" id="dice">ğŸ²</div>
    <button class="btn btn-roll" id="rollBtn" onclick="rollDice()">ğŸ² ×”×˜×œ ×§×•×‘×™×™×”</button>
  </div>
</div>

<canvas id="confetti"></canvas>

<script>
const BOARD_SIZE = 10;
const TOTAL = BOARD_SIZE * BOARD_SIZE;
const DICE_FACES = ['âš€','âš','âš‚','âšƒ','âš„','âš…'];

const SNAKES = {16:6, 47:26, 49:11, 56:53, 62:19, 64:60, 87:24, 93:73, 95:75, 98:78};
const LADDERS = {2:38, 7:14, 8:31, 15:26, 21:42, 28:84, 36:44, 51:67, 71:91, 78:98, 87:94};

const PLAYER_CONFIGS = [
  {color:'#f472b6', bg:'rgba(244,114,182,0.18)', emoji:'ğŸ©·', name:'×©×—×§×Ÿ 1'},
  {color:'#60a5fa', bg:'rgba(96,165,250,0.18)', emoji:'ğŸ’™', name:'×©×—×§×Ÿ 2'},
  {color:'#4ade80', bg:'rgba(74,222,128,0.18)', emoji:'ğŸ’š', name:'×©×—×§×Ÿ 3'},
  {color:'#fb923c', bg:'rgba(251,146,60,0.18)', emoji:'ğŸ§¡', name:'×©×—×§×Ÿ 4'},
];

let numPlayers = 2;
let players = [];
let current = 0;
let rolling = false;
let gameOver = false;

const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d');

// â”€â”€ Setup Screen â”€â”€

function selectPlayers(n) {
  numPlayers = n;
  document.querySelectorAll('.psel').forEach((b, i) => {
    b.classList.toggle('active', i === n - 2);
  });
  renderPreview();
}

function renderPreview() {
  const el = document.getElementById('playerPreview');
  el.innerHTML = PLAYER_CONFIGS.slice(0, numPlayers).map((p, i) =>
    `<div class="preview-chip" style="background:${p.bg};color:${p.color}">${p.emoji} ${p.name}</div>`
  ).join('');
}

function startGame() {
  players = PLAYER_CONFIGS.slice(0, numPlayers).map(c => ({
    pos: 0, color: c.color, name: c.name, emoji: c.emoji, bg: c.bg, _anim: null
  }));
  current = 0;
  rolling = false;
  gameOver = false;
  document.getElementById('setupScreen').classList.add('hidden');
  document.getElementById('gameWrap').classList.add('active');
  document.getElementById('winMsg').style.display = 'none';
  document.getElementById('dice').textContent = 'ğŸ²';
  document.getElementById('rollBtn').disabled = false;
  buildPlayerTags();
  updateTags();
  resize();
}

function backToSetup() {
  document.getElementById('setupScreen').classList.remove('hidden');
  document.getElementById('gameWrap').classList.remove('active');
  stopConfetti();
  renderPreview();
}

renderPreview();

// â”€â”€ Player Tags â”€â”€

function buildPlayerTags() {
  const bar = document.getElementById('playersBar');
  bar.innerHTML = players.map((p, i) =>
    `<div class="p" id="ptag${i}" style="background:${p.bg};color:${p.color}">${p.emoji} ${p.name}</div>`
  ).join('');
}

function updateTags() {
  players.forEach((_, i) => {
    const el = document.getElementById('ptag' + i);
    if (el) el.classList.toggle('active', i === current);
  });
}

// â”€â”€ Canvas â”€â”€

function resize() {
  const area = document.querySelector('.game-area');
  if (!area) return;
  const s = Math.min(area.clientWidth - 16, area.clientHeight - 16, 560);
  canvas.width = s;
  canvas.height = s;
  draw();
}
window.addEventListener('resize', resize);

function cellToXY(cell) {
  if (cell <= 0) return {x: -1, y: -1, cs: canvas.width / BOARD_SIZE};
  const idx = cell - 1;
  const row = Math.floor(idx / BOARD_SIZE);
  const col = idx % BOARD_SIZE;
  const actualCol = (row % 2 === 0) ? col : (BOARD_SIZE - 1 - col);
  const actualRow = BOARD_SIZE - 1 - row;
  const cs = canvas.width / BOARD_SIZE;
  return {x: actualCol * cs, y: actualRow * cs, cs};
}

function cellCenter(cell) {
  const {x, y, cs} = cellToXY(cell);
  return {x: x + cs / 2, y: y + cs / 2, cs};
}

function getPlayerXY(playerIdx) {
  const cs = canvas.width / BOARD_SIZE;
  const n = players.length;
  const offsets = {
    2: [{dx:0.33,dy:0.6},{dx:0.67,dy:0.6}],
    3: [{dx:0.25,dy:0.6},{dx:0.5,dy:0.6},{dx:0.75,dy:0.6}],
    4: [{dx:0.3,dy:0.48},{dx:0.7,dy:0.48},{dx:0.3,dy:0.73},{dx:0.7,dy:0.73}],
  };
  const o = (offsets[n] || offsets[2])[playerIdx] || {dx:0.5,dy:0.6};
  return {dx: o.dx * cs, dy: o.dy * cs};
}

// â”€â”€ Drawing â”€â”€

const ladderSet = new Set(Object.keys(LADDERS).map(Number));
const snakeSet = new Set(Object.keys(SNAKES).map(Number));

function draw() {
  const cs = canvas.width / BOARD_SIZE;
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  for (let i = 1; i <= TOTAL; i++) {
    const {x, y} = cellToXY(i);
    const row = Math.floor((i - 1) / BOARD_SIZE);
    const col = (i - 1) % BOARD_SIZE;
    const light = (row + col) % 2 === 0;

    if (ladderSet.has(i)) {
      ctx.fillStyle = light ? '#1a3328' : '#152a22';
    } else if (snakeSet.has(i)) {
      ctx.fillStyle = light ? '#3a1a1a' : '#2a1515';
    } else {
      ctx.fillStyle = light ? '#1e3a5f' : '#162032';
    }
    ctx.fillRect(x, y, cs, cs);

    ctx.strokeStyle = 'rgba(255,255,255,0.04)';
    ctx.lineWidth = 1;
    ctx.strokeRect(x, y, cs, cs);

    ctx.fillStyle = 'rgba(255,255,255,0.18)';
    ctx.font = `${cs * 0.2}px Rubik`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.fillText(i, x + cs / 2, y + cs * 0.06);
  }

  drawLadders(cs);
  drawSnakes(cs);
  drawPlayers(cs);
}

function drawLadders(cs) {
  for (const [from, to] of Object.entries(LADDERS)) {
    const a = cellToXY(+from);
    const b = cellToXY(+to);
    const ax = a.x + cs * 0.35, ay = a.y + cs / 2;
    const bx = b.x + cs * 0.35, by = b.y + cs / 2;
    const ax2 = a.x + cs * 0.65, bx2 = b.x + cs * 0.65;

    const grad = ctx.createLinearGradient(ax, ay, bx, by);
    grad.addColorStop(0, 'rgba(34,197,94,0.5)');
    grad.addColorStop(1, 'rgba(74,222,128,0.3)');
    ctx.strokeStyle = grad;
    ctx.lineWidth = cs * 0.09;
    ctx.lineCap = 'round';

    ctx.beginPath(); ctx.moveTo(ax, ay); ctx.lineTo(bx, by); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(ax2, ay); ctx.lineTo(bx2, by); ctx.stroke();

    const steps = 4;
    ctx.lineWidth = cs * 0.04;
    ctx.strokeStyle = 'rgba(34,197,94,0.35)';
    for (let s = 1; s <= steps; s++) {
      const t = s / (steps + 1);
      const rx1 = ax + (bx - ax) * t;
      const ry1 = ay + (by - ay) * t;
      const rx2 = ax2 + (bx2 - ax2) * t;
      const ry2 = ay + (by - ay) * t;
      ctx.beginPath(); ctx.moveTo(rx1, ry1); ctx.lineTo(rx2, ry2); ctx.stroke();
    }

    ctx.font = `${cs * 0.32}px serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('ğŸªœ', a.x + cs / 2, a.y + cs * 0.7);
  }
}

function drawSnakes(cs) {
  for (const [from, to] of Object.entries(SNAKES)) {
    const a = cellToXY(+from);
    const b = cellToXY(+to);
    const startX = a.x + cs / 2, startY = a.y + cs / 2;
    const endX = b.x + cs / 2, endY = b.y + cs / 2;

    const dx = endX - startX;
    const dy = endY - startY;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const waves = Math.max(2, Math.round(dist / (cs * 1.5)));

    const grad = ctx.createLinearGradient(startX, startY, endX, endY);
    grad.addColorStop(0, 'rgba(239,68,68,0.5)');
    grad.addColorStop(0.5, 'rgba(220,38,38,0.35)');
    grad.addColorStop(1, 'rgba(185,28,28,0.25)');

    ctx.strokeStyle = grad;
    ctx.lineWidth = cs * 0.1;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    ctx.beginPath();
    ctx.moveTo(startX, startY);
    const segments = 40;
    for (let i = 1; i <= segments; i++) {
      const t = i / segments;
      const x = startX + dx * t;
      const y = startY + dy * t;
      const perpX = -dy / dist;
      const perpY = dx / dist;
      const wobble = Math.sin(t * Math.PI * waves * 2) * cs * 0.2;
      ctx.lineTo(x + perpX * wobble, y + perpY * wobble);
    }
    ctx.stroke();

    ctx.strokeStyle = grad;
    ctx.lineWidth = cs * 0.05;
    ctx.beginPath();
    ctx.moveTo(startX, startY);
    for (let i = 1; i <= segments; i++) {
      const t = i / segments;
      const x = startX + dx * t;
      const y = startY + dy * t;
      const perpX = -dy / dist;
      const perpY = dx / dist;
      const wobble = Math.sin(t * Math.PI * waves * 2) * cs * 0.2;
      ctx.lineTo(x + perpX * wobble, y + perpY * wobble);
    }
    ctx.stroke();

    ctx.font = `${cs * 0.32}px serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('ğŸ', a.x + cs / 2, a.y + cs * 0.7);
  }
}

function drawPlayers(cs) {
  players.forEach((p, i) => {
    if (p.pos <= 0 && !p._anim) return;

    let px, py;
    if (p._anim) {
      px = p._anim.x;
      py = p._anim.y;
    } else {
      const {x, y} = cellToXY(p.pos);
      const off = getPlayerXY(i);
      px = x + off.dx;
      py = y + off.dy;
    }

    const r = cs * 0.17;

    ctx.shadowColor = p.color;
    ctx.shadowBlur = 12;
    ctx.beginPath();
    ctx.arc(px, py, r, 0, Math.PI * 2);
    ctx.fillStyle = p.color;
    ctx.fill();
    ctx.shadowBlur = 0;

    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    ctx.stroke();

    ctx.fillStyle = '#fff';
    ctx.font = `bold ${cs * 0.16}px Rubik`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(i + 1, px, py + 1);
  });
}

// â”€â”€ Animation: Normal Move â”€â”€

async function animateMove(playerIdx, from, to) {
  const step = from < to ? 1 : -1;
  let pos = from;
  while (pos !== to) {
    pos += step;
    players[playerIdx].pos = pos;
    draw();
    await new Promise(r => setTimeout(r, 90));
  }
}

// â”€â”€ Animation: Smooth Ladder / Snake â”€â”€

function showEventToast(type) {
  const toast = document.getElementById('eventToast');
  toast.className = 'event-toast';
  if (type === 'ladder') {
    toast.textContent = 'ğŸªœ ×¢×•×œ×™× ×‘×¡×•×œ×!';
    toast.classList.add('ladder-toast');
  } else {
    toast.textContent = 'ğŸ ××—×œ×™×§×™× ×‘× ×—×©!';
    toast.classList.add('snake-toast');
  }
  void toast.offsetWidth;
  toast.classList.add('show');
  setTimeout(() => toast.classList.remove('show'), 1800);
}

async function animateSpecialMove(playerIdx, fromCell, toCell, type) {
  const cs = canvas.width / BOARD_SIZE;
  const fromOff = getPlayerXY(playerIdx);
  const fromXY = cellToXY(fromCell);
  const toXY = cellToXY(toCell);

  const startX = fromXY.x + fromOff.dx;
  const startY = fromXY.y + fromOff.dy;
  const toOff = getPlayerXY(playerIdx);
  const endX = toXY.x + toOff.dx;
  const endY = toXY.y + toOff.dy;

  const isLadder = type === 'ladder';
  const duration = 1100;
  const startTime = performance.now();

  const dx = endX - startX;
  const dy = endY - startY;
  const cpX = (startX + endX) / 2 + (isLadder ? -cs * 0.6 : cs * 0.8);
  const cpY = (startY + endY) / 2;

  let particles = [];

  showEventToast(type);

  return new Promise(resolve => {
    function frame(now) {
      const elapsed = now - startTime;
      const rawT = Math.min(elapsed / duration, 1);

      const t = rawT < 0.5
        ? 4 * rawT * rawT * rawT
        : 1 - Math.pow(-2 * rawT + 2, 3) / 2;

      let x = (1 - t) * (1 - t) * startX + 2 * (1 - t) * t * cpX + t * t * endX;
      let y = (1 - t) * (1 - t) * startY + 2 * (1 - t) * t * cpY + t * t * endY;

      if (!isLadder) {
        const wobble = Math.sin(t * Math.PI * 6) * cs * 0.18;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
        x += (-dy / dist) * wobble;
        y += (dx / dist) * wobble;
      } else {
        const sway = Math.sin(t * Math.PI * 8) * cs * 0.06;
        x += sway;
      }

      players[playerIdx]._anim = {x, y};

      if (Math.random() > 0.3) {
        const spread = cs * 0.25;
        particles.push({
          x: x + (Math.random() - 0.5) * spread,
          y: y + (Math.random() - 0.5) * spread,
          vx: (Math.random() - 0.5) * 3,
          vy: isLadder ? -(Math.random() * 2 + 1) : (Math.random() * 1.5 + 0.5),
          life: 1,
          size: Math.random() * 4 + 1.5,
          hue: isLadder ? 120 + Math.random() * 40 : Math.random() * 25,
        });
      }

      particles = particles.filter(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.life -= 0.022;
        p.size *= 0.985;
        return p.life > 0;
      });

      draw();

      particles.forEach(p => {
        ctx.globalAlpha = p.life * 0.7;
        ctx.fillStyle = `hsl(${p.hue}, 85%, 60%)`;
        if (isLadder) {
          drawStar(p.x, p.y, p.size);
        } else {
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          ctx.fill();
        }
      });
      ctx.globalAlpha = 1;

      if (rawT < 1) {
        requestAnimationFrame(frame);
      } else {
        players[playerIdx]._anim = null;
        players[playerIdx].pos = toCell;
        burstParticles(endX, endY, isLadder);
        draw();
        resolve();
      }
    }

    requestAnimationFrame(frame);
  });
}

function drawStar(x, y, r) {
  ctx.beginPath();
  for (let i = 0; i < 5; i++) {
    const angle = (i * 4 * Math.PI) / 5 - Math.PI / 2;
    const method = i === 0 ? 'moveTo' : 'lineTo';
    ctx[method](x + r * Math.cos(angle), y + r * Math.sin(angle));
  }
  ctx.closePath();
  ctx.fill();
}

function burstParticles(cx, cy, isLadder) {
  const cs = canvas.width / BOARD_SIZE;
  let particles = [];
  for (let i = 0; i < 20; i++) {
    const angle = (Math.PI * 2 * i) / 20;
    const speed = 2 + Math.random() * 3;
    particles.push({
      x: cx, y: cy,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      life: 1,
      size: Math.random() * 4 + 2,
      hue: isLadder ? 120 + Math.random() * 40 : Math.random() * 25,
    });
  }

  function frame() {
    particles = particles.filter(p => {
      p.x += p.vx;
      p.y += p.vy;
      p.vx *= 0.96;
      p.vy *= 0.96;
      p.life -= 0.03;
      return p.life > 0;
    });
    if (particles.length === 0) return;
    draw();
    particles.forEach(p => {
      ctx.globalAlpha = p.life * 0.8;
      ctx.fillStyle = `hsl(${p.hue}, 85%, 60%)`;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
      ctx.fill();
    });
    ctx.globalAlpha = 1;
    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);
}

// â”€â”€ Dice Roll & Game Logic â”€â”€

async function rollDice() {
  if (rolling || gameOver) return;
  rolling = true;
  const btn = document.getElementById('rollBtn');
  const diceEl = document.getElementById('dice');
  btn.disabled = true;

  diceEl.classList.add('rolling');
  let val = 0;
  for (let i = 0; i < 10; i++) {
    val = Math.floor(Math.random() * 6) + 1;
    diceEl.textContent = DICE_FACES[val - 1];
    await new Promise(r => setTimeout(r, 70));
  }
  diceEl.classList.remove('rolling');

  const p = players[current];
  let newPos = p.pos + val;

  if (newPos > TOTAL) {
    nextPlayer();
    rolling = false;
    btn.disabled = false;
    return;
  }

  await animateMove(current, p.pos, newPos);

  if (newPos === TOTAL) {
    gameOver = true;
    const pc = PLAYER_CONFIGS[current];
    document.getElementById('winTitle').textContent = `${pc.emoji} ${pc.name} × ×™×¦×—! ğŸ‰`;
    document.getElementById('winText').textContent = `×‘-${DICE_FACES[val - 1]} ×”×’×™×¢ ×œ-100!`;
    document.getElementById('winMsg').style.display = 'block';
    launchConfetti();
    rolling = false;
    return;
  }

  if (LADDERS[newPos]) {
    await new Promise(r => setTimeout(r, 250));
    await animateSpecialMove(current, newPos, LADDERS[newPos], 'ladder');
    newPos = LADDERS[newPos];
  } else if (SNAKES[newPos]) {
    await new Promise(r => setTimeout(r, 250));
    await animateSpecialMove(current, newPos, SNAKES[newPos], 'snake');
    newPos = SNAKES[newPos];
  }

  players[current].pos = newPos;

  nextPlayer();
  rolling = false;
  btn.disabled = false;
}

function nextPlayer() {
  current = (current + 1) % players.length;
  updateTags();
}

// â”€â”€ Confetti â”€â”€

let confettiPieces = [];
let confettiRunning = false;
const confettiCanvas = document.getElementById('confetti');
const cctx = confettiCanvas.getContext('2d');

function launchConfetti() {
  confettiCanvas.width = window.innerWidth;
  confettiCanvas.height = window.innerHeight;
  confettiPieces = [];
  const colors = ['#f472b6','#60a5fa','#4ade80','#fb923c','#fbbf24','#a78bfa','#f87171','#34d399'];
  for (let i = 0; i < 150; i++) {
    confettiPieces.push({
      x: Math.random() * confettiCanvas.width,
      y: Math.random() * confettiCanvas.height * -1,
      w: Math.random() * 10 + 5,
      h: Math.random() * 6 + 3,
      color: colors[Math.floor(Math.random() * colors.length)],
      vy: Math.random() * 3 + 2,
      vx: (Math.random() - 0.5) * 2,
      rot: Math.random() * 360,
      rotV: (Math.random() - 0.5) * 10,
    });
  }
  confettiRunning = true;
  drawConfetti();
}

function stopConfetti() {
  confettiRunning = false;
  cctx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
}

function drawConfetti() {
  if (!confettiRunning) return;
  cctx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
  let alive = false;
  confettiPieces.forEach(p => {
    p.y += p.vy;
    p.x += p.vx;
    p.rot += p.rotV;
    if (p.y < confettiCanvas.height + 20) alive = true;
    cctx.save();
    cctx.translate(p.x, p.y);
    cctx.rotate((p.rot * Math.PI) / 180);
    cctx.fillStyle = p.color;
    cctx.fillRect(-p.w / 2, -p.h / 2, p.w, p.h);
    cctx.restore();
  });
  if (alive) requestAnimationFrame(drawConfetti);
  else confettiRunning = false;
}

// â”€â”€ Init â”€â”€

</script>
</body>
</html>
