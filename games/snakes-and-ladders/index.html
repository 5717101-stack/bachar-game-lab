<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>×¡×•×œ××•×ª ×•× ×—×©×™× ğŸ²</title>
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ğŸ²</text></svg>">
<link href="https://fonts.googleapis.com/css2?family=Rubik:wght@400;600;700;800;900&display=swap" rel="stylesheet">
<style>
:root {
  --bg: #0c0e1a;
  --surface: rgba(20,24,45,0.85);
  --surface2: rgba(30,38,65,0.7);
  --glass: rgba(255,255,255,0.04);
  --glass-border: rgba(255,255,255,0.08);
  --text: #eef2ff;
  --dim: rgba(255,255,255,0.45);
  --p1: #f472b6; --p1g: rgba(244,114,182,0.22);
  --p2: #60a5fa; --p2g: rgba(96,165,250,0.22);
  --p3: #4ade80; --p3g: rgba(74,222,128,0.22);
  --p4: #fb923c; --p4g: rgba(251,146,60,0.22);
  --ladder: #34d399;
  --snake: #fb7185;
  --accent1: #818cf8;
  --accent2: #f472b6;
  --accent3: #38bdf8;
  --radius: 18px;
}
* { margin:0; padding:0; box-sizing:border-box; }
html, body { height:100%; overflow:hidden; }
body {
  font-family:'Rubik',sans-serif;
  background:var(--bg);
  color:var(--text);
  display:flex; flex-direction:column;
}

.bg-glow {
  position:fixed; inset:0; z-index:0; pointer-events:none; overflow:hidden;
}
.bg-glow::before, .bg-glow::after {
  content:''; position:absolute; border-radius:50%; filter:blur(120px); opacity:0.18;
}
.bg-glow::before {
  width:500px; height:500px; top:-120px; right:-80px;
  background:radial-gradient(circle, #818cf8 0%, transparent 70%);
  animation:glowDrift 12s ease-in-out infinite alternate;
}
.bg-glow::after {
  width:450px; height:450px; bottom:-100px; left:-60px;
  background:radial-gradient(circle, #f472b6 0%, transparent 70%);
  animation:glowDrift 15s ease-in-out infinite alternate-reverse;
}
@keyframes glowDrift {
  0% { transform:translate(0,0) scale(1); }
  100% { transform:translate(60px,40px) scale(1.15); }
}

/* â”€â”€ Setup Screen â”€â”€ */
.setup-overlay {
  position:fixed; inset:0; z-index:100;
  background:transparent;
  display:flex; align-items:center; justify-content:center;
  padding:20px;
}
.setup-overlay.hidden { display:none; }
.setup-card {
  background:var(--surface);
  backdrop-filter:blur(40px); -webkit-backdrop-filter:blur(40px);
  border:1px solid var(--glass-border);
  border-radius:28px;
  padding:40px 36px;
  max-width:440px; width:100%;
  text-align:center;
  box-shadow: 0 25px 60px rgba(0,0,0,0.5), 0 0 0 1px rgba(255,255,255,0.05) inset;
  animation:cardIn 0.6s cubic-bezier(0.16,1,0.3,1) both;
}
@keyframes cardIn {
  0% { opacity:0; transform:scale(0.9) translateY(30px); }
  100% { opacity:1; transform:scale(1) translateY(0); }
}
.setup-icon {
  font-size:4em; margin-bottom:16px;
  animation:iconFloat 3s ease-in-out infinite;
  filter:drop-shadow(0 4px 12px rgba(0,0,0,0.4));
}
@keyframes iconFloat {
  0%,100% { transform:translateY(0) rotate(-2deg); }
  50% { transform:translateY(-12px) rotate(2deg); }
}
.setup-card h1 {
  font-size:2em; font-weight:900; letter-spacing:-0.5px;
  background:linear-gradient(135deg,#f472b6 0%,#818cf8 50%,#38bdf8 100%);
  -webkit-background-clip:text; -webkit-text-fill-color:transparent; background-clip:text;
  margin-bottom:8px;
}
.setup-card .subtitle {
  color:var(--dim); font-size:0.95em; margin-bottom:28px;
  font-weight:500;
}
.player-select { display:flex; gap:10px; justify-content:center; margin-bottom:24px; }
.psel {
  flex:1; padding:16px 8px; border-radius:16px;
  border:2px solid rgba(255,255,255,0.06); background:var(--glass);
  color:var(--text); font-family:'Rubik',sans-serif;
  cursor:pointer; transition:all 0.3s cubic-bezier(0.16,1,0.3,1);
  display:flex; flex-direction:column; align-items:center; gap:4px;
  backdrop-filter:blur(8px);
}
.psel:hover {
  border-color:rgba(255,255,255,0.15);
  background:rgba(255,255,255,0.06);
  transform:translateY(-2px);
}
.psel.active {
  border-color:var(--accent1);
  background:rgba(129,140,248,0.12);
  box-shadow:0 0 20px rgba(129,140,248,0.15);
  transform:translateY(-2px);
}
.psel-num { font-size:1.7em; font-weight:900; }
.psel-label { font-size:0.7em; font-weight:600; color:var(--dim); letter-spacing:0.5px; }
.player-preview {
  display:flex; justify-content:center; gap:10px; margin-bottom:28px;
  min-height:50px; align-items:center; flex-wrap:wrap;
}
.preview-chip {
  display:flex; align-items:center; gap:6px;
  padding:8px 16px; border-radius:14px;
  font-size:0.85em; font-weight:700;
  transition:all 0.35s cubic-bezier(0.16,1,0.3,1);
  border:1px solid rgba(255,255,255,0.06);
  animation:chipIn 0.4s cubic-bezier(0.16,1,0.3,1) both;
}
@keyframes chipIn {
  0% { opacity:0; transform:scale(0.8); }
  100% { opacity:1; transform:scale(1); }
}
.btn-start {
  width:100%; padding:16px; border-radius:16px; border:none;
  font-family:'Rubik',sans-serif; font-size:1.15em; font-weight:800;
  cursor:pointer; color:#fff; letter-spacing:0.3px;
  background:linear-gradient(135deg,#818cf8 0%,#c084fc 50%,#f472b6 100%);
  box-shadow:0 8px 30px rgba(129,140,248,0.3);
  transition:all 0.3s cubic-bezier(0.16,1,0.3,1);
  position:relative; overflow:hidden;
}
.btn-start::before {
  content:''; position:absolute; inset:0;
  background:linear-gradient(135deg, transparent 0%, rgba(255,255,255,0.15) 50%, transparent 100%);
  transform:translateX(-100%);
  transition:transform 0.5s;
}
.btn-start:hover::before { transform:translateX(100%); }
.btn-start:hover {
  filter:brightness(1.1);
  transform:translateY(-3px);
  box-shadow:0 12px 40px rgba(129,140,248,0.4);
}
.btn-start:active { transform:translateY(-1px); }

/* â”€â”€ Game UI â”€â”€ */
.game-wrap { display:none; flex-direction:column; height:100%; position:relative; z-index:1; }
.game-wrap.active { display:flex; }
.back-btn {
  position:fixed; top:12px; left:12px; z-index:9999;
  background:var(--surface); color:#fff; text-decoration:none;
  padding:8px 16px; border-radius:14px; font-size:0.85em;
  backdrop-filter:blur(20px); -webkit-backdrop-filter:blur(20px);
  border:1px solid var(--glass-border);
  transition:all 0.25s;
  font-weight:600;
}
.back-btn:hover { background:rgba(255,255,255,0.1); transform:translateY(-1px); }
.top-bar {
  display:flex; align-items:center; justify-content:space-between;
  padding:12px 18px;
  background:var(--surface);
  backdrop-filter:blur(30px); -webkit-backdrop-filter:blur(30px);
  border-bottom:1px solid var(--glass-border); flex-shrink:0;
}
.top-bar h1 {
  font-size:1.1em; font-weight:800;
  background:linear-gradient(135deg,#f472b6,#818cf8,#38bdf8);
  -webkit-background-clip:text; -webkit-text-fill-color:transparent; background-clip:text;
}
.players-bar { display:flex; gap:8px; font-size:0.8em; font-weight:700; flex-wrap:wrap; }
.players-bar .p {
  display:flex; align-items:center; gap:5px;
  padding:6px 12px; border-radius:12px;
  transition:all 0.35s cubic-bezier(0.16,1,0.3,1);
  border:2px solid transparent;
  position:relative;
}
.players-bar .p.active {
  border-color:currentColor;
  transform:scale(1.08);
  box-shadow:0 0 16px rgba(255,255,255,0.08);
}
.players-bar .p.active::after {
  content:'â—€'; position:absolute; right:-16px; font-size:0.7em;
  animation:pulse 1s ease-in-out infinite;
}
@keyframes pulse { 0%,100%{opacity:1} 50%{opacity:0.4} }
.game-area {
  flex:1; display:flex; align-items:center; justify-content:center;
  padding:8px; overflow:hidden; position:relative;
}
canvas#board {
  border-radius:16px;
  box-shadow:0 20px 60px rgba(0,0,0,0.4), 0 0 0 1px rgba(255,255,255,0.05);
}
.bottom-bar {
  display:flex; align-items:center; justify-content:center;
  gap:14px; padding:14px 18px;
  background:var(--surface);
  backdrop-filter:blur(30px); -webkit-backdrop-filter:blur(30px);
  border-top:1px solid var(--glass-border); flex-shrink:0;
}
.btn {
  padding:12px 28px; border-radius:14px; border:none;
  font-family:'Rubik',sans-serif; font-size:1em; font-weight:800;
  cursor:pointer; color:#fff; transition:all 0.25s cubic-bezier(0.16,1,0.3,1);
  position:relative; overflow:hidden;
}
.btn:hover { filter:brightness(1.12); transform:translateY(-2px); }
.btn:active { transform:translateY(0); }
.btn-roll {
  background:linear-gradient(135deg,#818cf8,#c084fc);
  box-shadow:0 6px 20px rgba(129,140,248,0.3);
  font-size:1.1em;
}
.btn-roll:disabled {
  opacity:0.35; cursor:not-allowed; transform:none;
  box-shadow:none;
}
.btn-new {
  background:rgba(255,255,255,0.08);
  border:1px solid rgba(255,255,255,0.08);
  font-size:0.85em;
}
.btn-new:hover { background:rgba(255,255,255,0.12); }
.dice-display {
  font-size:2.8em; min-width:64px; text-align:center;
  transition:transform 0.3s;
  filter:drop-shadow(0 4px 8px rgba(0,0,0,0.3));
}
.dice-display.rolling { animation:diceRoll 0.15s infinite; }
@keyframes diceRoll {
  0% { transform:rotate(0) scale(1); }
  25% { transform:rotate(-18deg) scale(1.1); }
  50% { transform:rotate(0) scale(0.95); }
  75% { transform:rotate(18deg) scale(1.1); }
  100% { transform:rotate(0) scale(1); }
}

/* â”€â”€ Event Toast â”€â”€ */
.event-toast {
  position:absolute; top:18%; left:50%; transform:translate(-50%,-50%) scale(0);
  padding:18px 32px; border-radius:20px;
  font-size:1.35em; font-weight:800; text-align:center;
  z-index:60; pointer-events:none;
  opacity:0; transition:none;
  backdrop-filter:blur(20px); -webkit-backdrop-filter:blur(20px);
}
.event-toast.ladder-toast {
  background:rgba(52,211,153,0.15);
  border:2px solid rgba(52,211,153,0.3);
  color:#6ee7b7;
  box-shadow:0 8px 30px rgba(52,211,153,0.2);
}
.event-toast.snake-toast {
  background:rgba(251,113,133,0.15);
  border:2px solid rgba(251,113,133,0.3);
  color:#fda4af;
  box-shadow:0 8px 30px rgba(251,113,133,0.2);
}
.event-toast.show {
  animation:toastIn 0.45s cubic-bezier(0.16,1,0.3,1) forwards, toastOut 0.4s ease 1.3s forwards;
}
@keyframes toastIn {
  0% { opacity:0; transform:translate(-50%,-50%) scale(0.5) translateY(10px); }
  100% { opacity:1; transform:translate(-50%,-50%) scale(1) translateY(0); }
}
@keyframes toastOut {
  0% { opacity:1; transform:translate(-50%,-50%) scale(1); }
  100% { opacity:0; transform:translate(-50%,-50%) scale(0.85) translateY(-15px); }
}

/* â”€â”€ Win overlay â”€â”€ */
.msg {
  position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
  background:var(--surface);
  backdrop-filter:blur(30px); -webkit-backdrop-filter:blur(30px);
  padding:40px 48px; border-radius:28px; text-align:center;
  z-index:50; pointer-events:auto; display:none;
  border:1px solid var(--glass-border);
  box-shadow:0 30px 80px rgba(0,0,0,0.6);
  animation:winIn 0.5s cubic-bezier(0.16,1,0.3,1) both;
}
@keyframes winIn {
  0% { opacity:0; transform:translate(-50%,-50%) scale(0.85); }
  100% { opacity:1; transform:translate(-50%,-50%) scale(1); }
}
.msg h2 { font-size:1.9em; margin-bottom:10px; }
.msg p { color:var(--dim); margin-bottom:22px; font-size:1.05em; }
.msg .btn { pointer-events:auto; }

/* â”€â”€ Confetti Canvas â”€â”€ */
#confetti {
  position:fixed; inset:0; z-index:45; pointer-events:none;
}
</style>
</head>
<body>

<div class="bg-glow"></div>

<a href="../../" class="back-btn">ğŸ  ××©×—×§×™×</a>

<!-- Setup Screen -->
<div class="setup-overlay" id="setupScreen">
  <div class="setup-card">
    <div class="setup-icon">ğŸğŸªœ</div>
    <h1>×¡×•×œ××•×ª ×•× ×—×©×™×</h1>
    <p class="subtitle">×‘×—×¨×• ××¡×¤×¨ ×©×—×§× ×™× ×•×”×ª×—×™×œ×•!</p>
    <div class="player-select">
      <button class="psel active" onclick="selectPlayers(2)">
        <span class="psel-num">2</span><span class="psel-label">×©×—×§× ×™×</span>
      </button>
      <button class="psel" onclick="selectPlayers(3)">
        <span class="psel-num">3</span><span class="psel-label">×©×—×§× ×™×</span>
      </button>
      <button class="psel" onclick="selectPlayers(4)">
        <span class="psel-num">4</span><span class="psel-label">×©×—×§× ×™×</span>
      </button>
    </div>
    <div class="player-preview" id="playerPreview"></div>
    <button class="btn-start" onclick="startGame()">ğŸ® ×”×ª×—×™×œ×• ×œ×©×—×§!</button>
  </div>
</div>

<!-- Game -->
<div class="game-wrap" id="gameWrap">
  <div class="top-bar">
    <h1>ğŸ ×¡×•×œ××•×ª ×•× ×—×©×™× ğŸªœ</h1>
    <div class="players-bar" id="playersBar"></div>
  </div>

  <div class="game-area">
    <canvas id="board"></canvas>
    <div class="event-toast" id="eventToast"></div>
    <div class="msg" id="winMsg">
      <h2 id="winTitle">ğŸ‰ × ×™×¦×—×•×Ÿ!</h2>
      <p id="winText"></p>
      <button class="btn btn-roll" onclick="backToSetup()">ğŸ”„ ××©×—×§ ×—×“×©</button>
    </div>
  </div>

  <div class="bottom-bar">
    <button class="btn btn-new" onclick="backToSetup()">ğŸ”„ ×—×“×©</button>
    <div class="dice-display" id="dice">ğŸ²</div>
    <button class="btn btn-roll" id="rollBtn" onclick="rollDice()">ğŸ² ×”×˜×œ ×§×•×‘×™×™×”</button>
  </div>
</div>

<canvas id="confetti"></canvas>

<script>
const BOARD_SIZE = 10;
const TOTAL = BOARD_SIZE * BOARD_SIZE;
const DICE_FACES = ['âš€','âš','âš‚','âšƒ','âš„','âš…'];

const SNAKES = {16:6, 47:26, 49:11, 56:53, 62:19, 64:60, 87:24, 93:73, 95:75, 98:78};
const LADDERS = {2:38, 7:14, 8:31, 15:26, 21:42, 28:84, 36:44, 51:67, 71:91, 78:98, 87:94};

const PLAYER_CONFIGS = [
  {color:'#f472b6', bg:'rgba(244,114,182,0.16)', emoji:'ğŸ©·', name:'×©×—×§×Ÿ 1'},
  {color:'#60a5fa', bg:'rgba(96,165,250,0.16)', emoji:'ğŸ’™', name:'×©×—×§×Ÿ 2'},
  {color:'#4ade80', bg:'rgba(74,222,128,0.16)', emoji:'ğŸ’š', name:'×©×—×§×Ÿ 3'},
  {color:'#fb923c', bg:'rgba(251,146,60,0.16)', emoji:'ğŸ§¡', name:'×©×—×§×Ÿ 4'},
];

const CELL_PALETTE = [
  {light:'#1a2747', dark:'#151f3a'},
  {light:'#1e2a4a', dark:'#172240'},
];

let numPlayers = 2;
let players = [];
let current = 0;
let rolling = false;
let gameOver = false;
let boardTime = 0;

const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d');

// â”€â”€ Setup Screen â”€â”€

function selectPlayers(n) {
  numPlayers = n;
  document.querySelectorAll('.psel').forEach((b, i) => {
    b.classList.toggle('active', i === n - 2);
  });
  renderPreview();
}

function renderPreview() {
  const el = document.getElementById('playerPreview');
  el.innerHTML = PLAYER_CONFIGS.slice(0, numPlayers).map((p, i) =>
    `<div class="preview-chip" style="background:${p.bg};color:${p.color};animation-delay:${i*0.08}s">${p.emoji} ${p.name}</div>`
  ).join('');
}

function startGame() {
  players = PLAYER_CONFIGS.slice(0, numPlayers).map(c => ({
    pos: 0, color: c.color, name: c.name, emoji: c.emoji, bg: c.bg, _anim: null
  }));
  current = 0;
  rolling = false;
  gameOver = false;
  document.getElementById('setupScreen').classList.add('hidden');
  document.getElementById('gameWrap').classList.add('active');
  document.getElementById('winMsg').style.display = 'none';
  document.getElementById('dice').textContent = 'ğŸ²';
  document.getElementById('rollBtn').disabled = false;
  buildPlayerTags();
  updateTags();
  resize();
  startBoardAnimation();
}

function backToSetup() {
  document.getElementById('setupScreen').classList.remove('hidden');
  document.getElementById('gameWrap').classList.remove('active');
  stopConfetti();
  renderPreview();
}

renderPreview();

// â”€â”€ Player Tags â”€â”€

function buildPlayerTags() {
  const bar = document.getElementById('playersBar');
  bar.innerHTML = players.map((p, i) =>
    `<div class="p" id="ptag${i}" style="background:${p.bg};color:${p.color}">${p.emoji} ${p.name}</div>`
  ).join('');
}

function updateTags() {
  players.forEach((_, i) => {
    const el = document.getElementById('ptag' + i);
    if (el) el.classList.toggle('active', i === current);
  });
}

// â”€â”€ Canvas â”€â”€

function resize() {
  const area = document.querySelector('.game-area');
  if (!area) return;
  const s = Math.min(area.clientWidth - 16, area.clientHeight - 16, 580);
  canvas.width = s;
  canvas.height = s;
  draw();
}
window.addEventListener('resize', resize);

function cellToXY(cell) {
  if (cell <= 0) return {x: -1, y: -1, cs: canvas.width / BOARD_SIZE};
  const idx = cell - 1;
  const row = Math.floor(idx / BOARD_SIZE);
  const col = idx % BOARD_SIZE;
  const actualCol = (row % 2 === 0) ? col : (BOARD_SIZE - 1 - col);
  const actualRow = BOARD_SIZE - 1 - row;
  const cs = canvas.width / BOARD_SIZE;
  return {x: actualCol * cs, y: actualRow * cs, cs};
}

function cellCenter(cell) {
  const {x, y, cs} = cellToXY(cell);
  return {x: x + cs / 2, y: y + cs / 2, cs};
}

function getPlayerXY(playerIdx) {
  const cs = canvas.width / BOARD_SIZE;
  const n = players.length;
  const offsets = {
    2: [{dx:0.33,dy:0.6},{dx:0.67,dy:0.6}],
    3: [{dx:0.25,dy:0.6},{dx:0.5,dy:0.6},{dx:0.75,dy:0.6}],
    4: [{dx:0.3,dy:0.48},{dx:0.7,dy:0.48},{dx:0.3,dy:0.73},{dx:0.7,dy:0.73}],
  };
  const o = (offsets[n] || offsets[2])[playerIdx] || {dx:0.5,dy:0.6};
  return {dx: o.dx * cs, dy: o.dy * cs};
}

// â”€â”€ Subtle Board Animation â”€â”€

let animFrame = null;
function startBoardAnimation() {
  if (animFrame) return;
  function tick() {
    boardTime = Date.now() * 0.001;
    draw();
    animFrame = requestAnimationFrame(tick);
  }
  tick();
}

// â”€â”€ Drawing â”€â”€

const ladderSet = new Set(Object.keys(LADDERS).map(Number));
const snakeSet = new Set(Object.keys(SNAKES).map(Number));
const ladderDestSet = new Set(Object.values(LADDERS));
const snakeDestSet = new Set(Object.values(SNAKES));

function hexToRgb(hex) {
  const r = parseInt(hex.slice(1,3),16);
  const g = parseInt(hex.slice(3,5),16);
  const b = parseInt(hex.slice(5,7),16);
  return {r,g,b};
}

function draw() {
  const cs = canvas.width / BOARD_SIZE;
  const gap = 1.5;
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Board background
  ctx.fillStyle = '#0d1225';
  ctx.beginPath();
  ctx.roundRect(0, 0, canvas.width, canvas.height, 14);
  ctx.fill();

  for (let i = 1; i <= TOTAL; i++) {
    const {x, y} = cellToXY(i);
    const row = Math.floor((i - 1) / BOARD_SIZE);
    const col = (i - 1) % BOARD_SIZE;
    const light = (row + col) % 2 === 0;

    let baseColor1, baseColor2;
    const isStart = i === 1;
    const isFinish = i === TOTAL;

    if (isFinish) {
      const pulse = Math.sin(boardTime * 2) * 0.1 + 0.9;
      baseColor1 = `rgba(251,191,36,${0.25 * pulse})`;
      baseColor2 = `rgba(245,158,11,${0.2 * pulse})`;
    } else if (isStart) {
      baseColor1 = 'rgba(129,140,248,0.2)';
      baseColor2 = 'rgba(99,102,241,0.15)';
    } else if (ladderSet.has(i)) {
      baseColor1 = 'rgba(52,211,153,0.12)';
      baseColor2 = 'rgba(16,185,129,0.08)';
    } else if (snakeSet.has(i)) {
      baseColor1 = 'rgba(251,113,133,0.12)';
      baseColor2 = 'rgba(244,63,94,0.08)';
    } else {
      baseColor1 = light ? '#1c2b4a' : '#172340';
      baseColor2 = light ? '#182544' : '#14203a';
    }

    const cellGrad = ctx.createLinearGradient(x, y, x, y + cs);
    cellGrad.addColorStop(0, baseColor1);
    cellGrad.addColorStop(1, baseColor2);

    ctx.beginPath();
    ctx.roundRect(x + gap, y + gap, cs - gap * 2, cs - gap * 2, 6);
    ctx.fillStyle = cellGrad;
    ctx.fill();

    // Subtle inner border glow
    ctx.strokeStyle = 'rgba(255,255,255,0.04)';
    ctx.lineWidth = 0.5;
    ctx.stroke();

    // Cell number
    if (isFinish) {
      ctx.fillStyle = '#fbbf24';
      ctx.font = `bold ${cs * 0.22}px Rubik`;
    } else if (isStart) {
      ctx.fillStyle = '#818cf8';
      ctx.font = `bold ${cs * 0.22}px Rubik`;
    } else {
      ctx.fillStyle = 'rgba(255,255,255,0.2)';
      ctx.font = `600 ${cs * 0.19}px Rubik`;
    }
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.fillText(i, x + cs / 2, y + cs * 0.07);

    if (isFinish) {
      ctx.font = `${cs * 0.28}px serif`;
      ctx.textBaseline = 'middle';
      ctx.fillText('ğŸ†', x + cs / 2, y + cs * 0.65);
    }
    if (isStart) {
      ctx.font = `${cs * 0.22}px serif`;
      ctx.textBaseline = 'middle';
      ctx.fillText('ğŸš€', x + cs / 2, y + cs * 0.65);
    }
  }

  drawLadders(cs);
  drawSnakes(cs);
  drawPlayers(cs);
}

function drawLadders(cs) {
  for (const [from, to] of Object.entries(LADDERS)) {
    const a = cellToXY(+from);
    const b = cellToXY(+to);
    const railOffL = 0.32, railOffR = 0.68;
    const ax1 = a.x + cs * railOffL, ay = a.y + cs * 0.5;
    const bx1 = b.x + cs * railOffL, by = b.y + cs * 0.5;
    const ax2 = a.x + cs * railOffR;
    const bx2 = b.x + cs * railOffR;

    // Ladder shadow
    ctx.save();
    ctx.globalAlpha = 0.15;
    ctx.strokeStyle = '#000';
    ctx.lineWidth = cs * 0.12;
    ctx.lineCap = 'round';
    ctx.beginPath(); ctx.moveTo(ax1+2, ay+3); ctx.lineTo(bx1+2, by+3); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(ax2+2, ay+3); ctx.lineTo(bx2+2, by+3); ctx.stroke();
    ctx.restore();

    // Rail gradient - golden/warm wood look
    const railGrad = ctx.createLinearGradient(ax1, ay, bx1, by);
    railGrad.addColorStop(0, '#d4a56a');
    railGrad.addColorStop(0.3, '#c9935a');
    railGrad.addColorStop(0.6, '#b8834e');
    railGrad.addColorStop(1, '#a67542');

    ctx.strokeStyle = railGrad;
    ctx.lineWidth = cs * 0.07;
    ctx.lineCap = 'round';
    ctx.beginPath(); ctx.moveTo(ax1, ay); ctx.lineTo(bx1, by); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(ax2, ay); ctx.lineTo(bx2, by); ctx.stroke();

    // Inner highlight on rails
    const highlightGrad = ctx.createLinearGradient(ax1, ay, bx1, by);
    highlightGrad.addColorStop(0, 'rgba(255,220,150,0.4)');
    highlightGrad.addColorStop(0.5, 'rgba(255,220,150,0.1)');
    highlightGrad.addColorStop(1, 'rgba(255,220,150,0.25)');
    ctx.strokeStyle = highlightGrad;
    ctx.lineWidth = cs * 0.025;
    ctx.beginPath(); ctx.moveTo(ax1 - 1, ay); ctx.lineTo(bx1 - 1, by); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(ax2 - 1, ay); ctx.lineTo(bx2 - 1, by); ctx.stroke();

    // Rungs
    const steps = 5;
    const rungGrad = ctx.createLinearGradient(ax1, ay, ax2, ay);
    rungGrad.addColorStop(0, '#c9935a');
    rungGrad.addColorStop(0.5, '#dab88a');
    rungGrad.addColorStop(1, '#c9935a');

    ctx.lineWidth = cs * 0.04;
    ctx.strokeStyle = rungGrad;
    for (let s = 1; s <= steps; s++) {
      const t = s / (steps + 1);
      const rx1 = ax1 + (bx1 - ax1) * t;
      const ry1 = ay + (by - ay) * t;
      const rx2 = ax2 + (bx2 - ax2) * t;
      const ry2 = ay + (by - ay) * t;
      ctx.beginPath(); ctx.moveTo(rx1, ry1); ctx.lineTo(rx2, ry2); ctx.stroke();
    }

    // Green glow around ladder base
    ctx.save();
    ctx.globalAlpha = 0.12;
    const glowR = cs * 0.4;
    const ladderGlow = ctx.createRadialGradient(a.x+cs/2, a.y+cs/2, 0, a.x+cs/2, a.y+cs/2, glowR);
    ladderGlow.addColorStop(0, '#34d399');
    ladderGlow.addColorStop(1, 'transparent');
    ctx.fillStyle = ladderGlow;
    ctx.fillRect(a.x, a.y, cs, cs);
    ctx.restore();

    // Arrow indicator
    ctx.font = `${cs * 0.24}px serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('â¬†ï¸', a.x + cs / 2, a.y + cs * 0.75);
  }
}

function drawSnakes(cs) {
  for (const [from, to] of Object.entries(SNAKES)) {
    const a = cellToXY(+from);
    const b = cellToXY(+to);
    const startX = a.x + cs / 2, startY = a.y + cs / 2;
    const endX = b.x + cs / 2, endY = b.y + cs / 2;

    const dx = endX - startX;
    const dy = endY - startY;
    const dist = Math.sqrt(dx * dx + dy * dy) || 1;
    const waves = Math.max(2, Math.round(dist / (cs * 1.2)));
    const segments = 50;

    function getSnakePoint(t, thickness) {
      const x = startX + dx * t;
      const y = startY + dy * t;
      const perpX = -dy / dist;
      const perpY = dx / dist;
      const wobble = Math.sin(t * Math.PI * waves * 2 + boardTime * 1.5) * cs * 0.22;
      return {
        x: x + perpX * (wobble + (thickness || 0)),
        y: y + perpY * (wobble + (thickness || 0))
      };
    }

    // Snake body shadow
    ctx.save();
    ctx.globalAlpha = 0.2;
    ctx.strokeStyle = '#000';
    ctx.lineWidth = cs * 0.14;
    ctx.lineCap = 'round'; ctx.lineJoin = 'round';
    ctx.beginPath();
    let sp = getSnakePoint(0);
    ctx.moveTo(sp.x + 2, sp.y + 3);
    for (let i = 1; i <= segments; i++) {
      sp = getSnakePoint(i / segments);
      ctx.lineTo(sp.x + 2, sp.y + 3);
    }
    ctx.stroke();
    ctx.restore();

    // Main body
    const bodyGrad = ctx.createLinearGradient(startX, startY, endX, endY);
    bodyGrad.addColorStop(0, '#ef4444');
    bodyGrad.addColorStop(0.3, '#dc2626');
    bodyGrad.addColorStop(0.6, '#b91c1c');
    bodyGrad.addColorStop(1, '#991b1b');

    ctx.strokeStyle = bodyGrad;
    ctx.lineWidth = cs * 0.11;
    ctx.lineCap = 'round'; ctx.lineJoin = 'round';
    ctx.beginPath();
    sp = getSnakePoint(0);
    ctx.moveTo(sp.x, sp.y);
    for (let i = 1; i <= segments; i++) {
      sp = getSnakePoint(i / segments);
      ctx.lineTo(sp.x, sp.y);
    }
    ctx.stroke();

    // Body pattern (belly highlight)
    const bellyGrad = ctx.createLinearGradient(startX, startY, endX, endY);
    bellyGrad.addColorStop(0, 'rgba(255,200,180,0.35)');
    bellyGrad.addColorStop(0.5, 'rgba(255,180,160,0.2)');
    bellyGrad.addColorStop(1, 'rgba(255,160,140,0.25)');

    ctx.strokeStyle = bellyGrad;
    ctx.lineWidth = cs * 0.04;
    ctx.beginPath();
    sp = getSnakePoint(0);
    ctx.moveTo(sp.x, sp.y);
    for (let i = 1; i <= segments; i++) {
      sp = getSnakePoint(i / segments);
      ctx.lineTo(sp.x, sp.y);
    }
    ctx.stroke();

    // Diamond pattern markings
    ctx.save();
    for (let i = 2; i < segments - 2; i += 4) {
      const t = i / segments;
      const p = getSnakePoint(t);
      const size = cs * 0.04;
      ctx.globalAlpha = 0.3;
      ctx.fillStyle = '#fca5a5';
      ctx.beginPath();
      ctx.moveTo(p.x, p.y - size);
      ctx.lineTo(p.x + size * 0.7, p.y);
      ctx.lineTo(p.x, p.y + size);
      ctx.lineTo(p.x - size * 0.7, p.y);
      ctx.closePath();
      ctx.fill();
    }
    ctx.restore();

    // Snake head
    const head = getSnakePoint(0);
    ctx.save();
    ctx.beginPath();
    ctx.arc(head.x, head.y, cs * 0.1, 0, Math.PI * 2);
    const headGrad = ctx.createRadialGradient(head.x - 2, head.y - 2, 0, head.x, head.y, cs * 0.1);
    headGrad.addColorStop(0, '#f87171');
    headGrad.addColorStop(1, '#dc2626');
    ctx.fillStyle = headGrad;
    ctx.fill();

    // Eyes
    const eyeOff = cs * 0.04;
    const eyeR = cs * 0.022;
    const angle = Math.atan2(dy, dx);
    const perpAngle = angle + Math.PI / 2;
    for (const side of [-1, 1]) {
      const ex = head.x + Math.cos(perpAngle) * eyeOff * side - Math.cos(angle) * cs * 0.03;
      const ey = head.y + Math.sin(perpAngle) * eyeOff * side - Math.sin(angle) * cs * 0.03;
      ctx.beginPath();
      ctx.arc(ex, ey, eyeR, 0, Math.PI * 2);
      ctx.fillStyle = '#fef3c7';
      ctx.fill();
      ctx.beginPath();
      ctx.arc(ex, ey, eyeR * 0.5, 0, Math.PI * 2);
      ctx.fillStyle = '#1a1a2e';
      ctx.fill();
    }
    ctx.restore();

    // Red glow around snake head
    ctx.save();
    ctx.globalAlpha = 0.1;
    const snakeGlow = ctx.createRadialGradient(a.x+cs/2, a.y+cs/2, 0, a.x+cs/2, a.y+cs/2, cs*0.4);
    snakeGlow.addColorStop(0, '#fb7185');
    snakeGlow.addColorStop(1, 'transparent');
    ctx.fillStyle = snakeGlow;
    ctx.fillRect(a.x, a.y, cs, cs);
    ctx.restore();

    ctx.font = `${cs * 0.18}px serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('â¬‡ï¸', a.x + cs / 2, a.y + cs * 0.78);
  }
}

function drawPlayers(cs) {
  players.forEach((p, i) => {
    if (p.pos <= 0 && !p._anim) return;

    let px, py;
    if (p._anim) {
      px = p._anim.x;
      py = p._anim.y;
    } else {
      const {x, y} = cellToXY(p.pos);
      const off = getPlayerXY(i);
      px = x + off.dx;
      py = y + off.dy;
    }

    const r = cs * 0.18;
    const isActive = i === current && !gameOver;

    // Pulsing glow for active player
    if (isActive) {
      const pulseR = r + Math.sin(boardTime * 4) * 3 + 4;
      ctx.save();
      ctx.globalAlpha = 0.25 + Math.sin(boardTime * 4) * 0.1;
      const glowGrad = ctx.createRadialGradient(px, py, r * 0.5, px, py, pulseR + 6);
      glowGrad.addColorStop(0, p.color);
      glowGrad.addColorStop(1, 'transparent');
      ctx.fillStyle = glowGrad;
      ctx.beginPath();
      ctx.arc(px, py, pulseR + 6, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    // Token shadow
    ctx.save();
    ctx.globalAlpha = 0.3;
    ctx.beginPath();
    ctx.ellipse(px + 1, py + 3, r * 0.9, r * 0.5, 0, 0, Math.PI * 2);
    ctx.fillStyle = '#000';
    ctx.fill();
    ctx.restore();

    // Main token body - gradient sphere
    const tokenGrad = ctx.createRadialGradient(px - r * 0.3, py - r * 0.3, r * 0.1, px, py, r);
    const rgb = hexToRgb(p.color);
    tokenGrad.addColorStop(0, `rgba(${Math.min(rgb.r+80,255)},${Math.min(rgb.g+80,255)},${Math.min(rgb.b+80,255)},1)`);
    tokenGrad.addColorStop(0.6, p.color);
    tokenGrad.addColorStop(1, `rgba(${Math.max(rgb.r-50,0)},${Math.max(rgb.g-50,0)},${Math.max(rgb.b-50,0)},1)`);

    ctx.beginPath();
    ctx.arc(px, py, r, 0, Math.PI * 2);
    ctx.fillStyle = tokenGrad;
    ctx.fill();

    // Glossy highlight
    ctx.beginPath();
    ctx.ellipse(px - r * 0.15, py - r * 0.25, r * 0.45, r * 0.3, -0.3, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(255,255,255,0.3)';
    ctx.fill();

    // Border ring
    ctx.beginPath();
    ctx.arc(px, py, r, 0, Math.PI * 2);
    ctx.strokeStyle = 'rgba(255,255,255,0.5)';
    ctx.lineWidth = 1.5;
    ctx.stroke();

    // Player number
    ctx.fillStyle = '#fff';
    ctx.font = `bold ${cs * 0.16}px Rubik`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.shadowColor = 'rgba(0,0,0,0.5)';
    ctx.shadowBlur = 3;
    ctx.fillText(i + 1, px, py + 1);
    ctx.shadowBlur = 0;
  });
}

// â”€â”€ Animation: Normal Move â”€â”€

async function animateMove(playerIdx, from, to) {
  const step = from < to ? 1 : -1;
  let pos = from;
  while (pos !== to) {
    pos += step;
    players[playerIdx].pos = pos;
    draw();
    await new Promise(r => setTimeout(r, 85));
  }
}

// â”€â”€ Animation: Smooth Ladder / Snake â”€â”€

function showEventToast(type) {
  const toast = document.getElementById('eventToast');
  toast.className = 'event-toast';
  if (type === 'ladder') {
    toast.textContent = 'ğŸªœ ×¢×•×œ×™× ×‘×¡×•×œ×!';
    toast.classList.add('ladder-toast');
  } else {
    toast.textContent = 'ğŸ ××—×œ×™×§×™× ×‘× ×—×©!';
    toast.classList.add('snake-toast');
  }
  void toast.offsetWidth;
  toast.classList.add('show');
  setTimeout(() => toast.classList.remove('show'), 1800);
}

async function animateSpecialMove(playerIdx, fromCell, toCell, type) {
  const cs = canvas.width / BOARD_SIZE;
  const fromOff = getPlayerXY(playerIdx);
  const fromXY = cellToXY(fromCell);
  const toXY = cellToXY(toCell);

  const startX = fromXY.x + fromOff.dx;
  const startY = fromXY.y + fromOff.dy;
  const toOff = getPlayerXY(playerIdx);
  const endX = toXY.x + toOff.dx;
  const endY = toXY.y + toOff.dy;

  const isLadder = type === 'ladder';
  const duration = 1100;
  const startTime = performance.now();

  const dx = endX - startX;
  const dy = endY - startY;
  const cpX = (startX + endX) / 2 + (isLadder ? -cs * 0.6 : cs * 0.8);
  const cpY = (startY + endY) / 2;

  let particles = [];

  showEventToast(type);

  return new Promise(resolve => {
    function frame(now) {
      const elapsed = now - startTime;
      const rawT = Math.min(elapsed / duration, 1);

      const t = rawT < 0.5
        ? 4 * rawT * rawT * rawT
        : 1 - Math.pow(-2 * rawT + 2, 3) / 2;

      let x = (1 - t) * (1 - t) * startX + 2 * (1 - t) * t * cpX + t * t * endX;
      let y = (1 - t) * (1 - t) * startY + 2 * (1 - t) * t * cpY + t * t * endY;

      if (!isLadder) {
        const wobble = Math.sin(t * Math.PI * 6) * cs * 0.18;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
        x += (-dy / dist) * wobble;
        y += (dx / dist) * wobble;
      } else {
        const sway = Math.sin(t * Math.PI * 8) * cs * 0.06;
        x += sway;
      }

      players[playerIdx]._anim = {x, y};

      if (Math.random() > 0.25) {
        const spread = cs * 0.3;
        particles.push({
          x: x + (Math.random() - 0.5) * spread,
          y: y + (Math.random() - 0.5) * spread,
          vx: (Math.random() - 0.5) * 3,
          vy: isLadder ? -(Math.random() * 2.5 + 1) : (Math.random() * 1.5 + 0.5),
          life: 1,
          size: Math.random() * 4 + 2,
          hue: isLadder ? 150 + Math.random() * 30 : 340 + Math.random() * 30,
        });
      }

      particles = particles.filter(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.life -= 0.02;
        p.size *= 0.987;
        return p.life > 0;
      });

      draw();

      particles.forEach(p => {
        ctx.globalAlpha = p.life * 0.7;
        ctx.fillStyle = `hsl(${p.hue}, 80%, 65%)`;
        if (isLadder) {
          drawStar(p.x, p.y, p.size);
        } else {
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          ctx.fill();
        }
      });
      ctx.globalAlpha = 1;

      if (rawT < 1) {
        requestAnimationFrame(frame);
      } else {
        players[playerIdx]._anim = null;
        players[playerIdx].pos = toCell;
        burstParticles(endX, endY, isLadder);
        draw();
        resolve();
      }
    }

    requestAnimationFrame(frame);
  });
}

function drawStar(x, y, r) {
  ctx.beginPath();
  for (let i = 0; i < 5; i++) {
    const angle = (i * 4 * Math.PI) / 5 - Math.PI / 2;
    const method = i === 0 ? 'moveTo' : 'lineTo';
    ctx[method](x + r * Math.cos(angle), y + r * Math.sin(angle));
  }
  ctx.closePath();
  ctx.fill();
}

function burstParticles(cx, cy, isLadder) {
  let particles = [];
  for (let i = 0; i < 24; i++) {
    const angle = (Math.PI * 2 * i) / 24;
    const speed = 2.5 + Math.random() * 3.5;
    particles.push({
      x: cx, y: cy,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      life: 1,
      size: Math.random() * 4.5 + 2,
      hue: isLadder ? 150 + Math.random() * 30 : 340 + Math.random() * 30,
    });
  }

  function frame() {
    particles = particles.filter(p => {
      p.x += p.vx;
      p.y += p.vy;
      p.vx *= 0.96;
      p.vy *= 0.96;
      p.life -= 0.028;
      return p.life > 0;
    });
    if (particles.length === 0) return;
    draw();
    particles.forEach(p => {
      ctx.globalAlpha = p.life * 0.8;
      ctx.fillStyle = `hsl(${p.hue}, 80%, 65%)`;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
      ctx.fill();
    });
    ctx.globalAlpha = 1;
    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);
}

// â”€â”€ Dice Roll & Game Logic â”€â”€

async function rollDice() {
  if (rolling || gameOver) return;
  rolling = true;
  const btn = document.getElementById('rollBtn');
  const diceEl = document.getElementById('dice');
  btn.disabled = true;

  diceEl.classList.add('rolling');
  let val = 0;
  for (let i = 0; i < 12; i++) {
    val = Math.floor(Math.random() * 6) + 1;
    diceEl.textContent = DICE_FACES[val - 1];
    await new Promise(r => setTimeout(r, 60 + i * 5));
  }
  diceEl.classList.remove('rolling');

  const p = players[current];
  let newPos = p.pos + val;

  if (newPos > TOTAL) {
    nextPlayer();
    rolling = false;
    btn.disabled = false;
    return;
  }

  await animateMove(current, p.pos, newPos);

  if (newPos === TOTAL) {
    gameOver = true;
    const pc = PLAYER_CONFIGS[current];
    document.getElementById('winTitle').textContent = `${pc.emoji} ${pc.name} × ×™×¦×—! ğŸ‰`;
    document.getElementById('winText').textContent = `×‘-${DICE_FACES[val - 1]} ×”×’×™×¢ ×œ-100!`;
    document.getElementById('winMsg').style.display = 'block';
    launchConfetti();
    rolling = false;
    return;
  }

  if (LADDERS[newPos]) {
    await new Promise(r => setTimeout(r, 250));
    await animateSpecialMove(current, newPos, LADDERS[newPos], 'ladder');
    newPos = LADDERS[newPos];
  } else if (SNAKES[newPos]) {
    await new Promise(r => setTimeout(r, 250));
    await animateSpecialMove(current, newPos, SNAKES[newPos], 'snake');
    newPos = SNAKES[newPos];
  }

  players[current].pos = newPos;

  nextPlayer();
  rolling = false;
  btn.disabled = false;
}

function nextPlayer() {
  current = (current + 1) % players.length;
  updateTags();
}

// â”€â”€ Confetti â”€â”€

let confettiPieces = [];
let confettiRunning = false;
const confettiCanvas = document.getElementById('confetti');
const cctx = confettiCanvas.getContext('2d');

function launchConfetti() {
  confettiCanvas.width = window.innerWidth;
  confettiCanvas.height = window.innerHeight;
  confettiPieces = [];
  const colors = ['#f472b6','#60a5fa','#4ade80','#fb923c','#fbbf24','#a78bfa','#f87171','#34d399','#818cf8','#c084fc'];
  for (let i = 0; i < 200; i++) {
    confettiPieces.push({
      x: Math.random() * confettiCanvas.width,
      y: Math.random() * confettiCanvas.height * -1.2,
      w: Math.random() * 10 + 5,
      h: Math.random() * 6 + 3,
      color: colors[Math.floor(Math.random() * colors.length)],
      vy: Math.random() * 3 + 2,
      vx: (Math.random() - 0.5) * 2.5,
      rot: Math.random() * 360,
      rotV: (Math.random() - 0.5) * 12,
      opacity: Math.random() * 0.5 + 0.5,
    });
  }
  confettiRunning = true;
  drawConfetti();
}

function stopConfetti() {
  confettiRunning = false;
  cctx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
}

function drawConfetti() {
  if (!confettiRunning) return;
  cctx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
  let alive = false;
  confettiPieces.forEach(p => {
    p.y += p.vy;
    p.x += p.vx;
    p.rot += p.rotV;
    p.vx += (Math.random() - 0.5) * 0.1;
    if (p.y < confettiCanvas.height + 20) alive = true;
    cctx.save();
    cctx.globalAlpha = p.opacity;
    cctx.translate(p.x, p.y);
    cctx.rotate((p.rot * Math.PI) / 180);
    cctx.fillStyle = p.color;
    cctx.fillRect(-p.w / 2, -p.h / 2, p.w, p.h);
    cctx.restore();
  });
  if (alive) requestAnimationFrame(drawConfetti);
  else confettiRunning = false;
}

// â”€â”€ Init â”€â”€

</script>
</body>
</html>
